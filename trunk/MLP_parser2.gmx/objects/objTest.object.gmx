<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
var tvariables;
variables = ds_map_create();

ds_map_add(variables, "globalvariable", 200);
ds_map_add(variables, "pi", pi);
ds_map_add(variables, "e", exp(1));
ds_map_add(variables, "var1", 1);
ds_map_add(variables, "var2", 1);
ds_map_add(variables, "var3", 1);
ds_map_add(variables, "str1", "");
ds_map_add(variables, "str2", "");
ds_map_add(variables, "str3", "");

tvariables = ds_map_create();
ds_map_copy(tvariables, variables);
myfunc = MLP_InitParserCS(variables);
str = "angle_difference(-270,720)"
with (myfunc) {
    MLP_AddFunction("angle_difference",AngleDifference, MLP_VAL_REAL, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_SetExpression(other.str);
}

tvariables = ds_map_create();
ds_map_copy(tvariables, variables);
myfunc = MLP_InitParserCS(variables);
str = "6 &lt;&lt; 2"
with (myfunc) {
    MLP_SetExpression(other.str);
}

tvariables = ds_map_create();
ds_map_copy(tvariables, variables);
str = "sin( pi / 2) +globalvariable"
myfunc = MLP_InitParserCS(variables);
with (myfunc) {
    MLP_AddVariable("globalvariable");
    MLP_AddVariable("pi", pi); //3rd argument is unnecessary as variable is already initialized
    MLP_AddFunction("sin",_MLP_FSin,MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_SetExpression(other.str);
}

tvariables = ds_map_create();
ds_map_copy(tvariables, variables);
str = "2*4 nCr 2*2"
myfunc = MLP_InitParserCS(variables);
with (myfunc) {
    //a * b nCr c * d = a * (b nCr c) * d
    MLP_AddBinaryOper("nCr",12,_MLP_FCombination, MLP_VAL_REAL, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_SetExpression(other.str);
}

tvariables = ds_map_create();
ds_map_copy(tvariables, variables);
str = "rand() - 0.5"
myfunc = MLP_InitParserCS(variables);
with (myfunc) {
    MLP_AddFunction("rand",myRandom, MLP_VAL_REAL);
    MLP_SetExpression(other.str);
}


tvariables = ds_map_create();
ds_map_copy(tvariables, variables);
str = "2 &lt;= 4 ^^ 4 &gt; 5";
myfunc = MLP_InitParserCS(variables);
with (myfunc) {
    MLP_SetExpression(other.str);
}


tvariables = ds_map_create();
ds_map_copy(tvariables, variables);
str = "2 * * 5"
myfunc = MLP_InitParserCS(variables);
with (myfunc) {
    MLP_SetExpression(other.str);
}

tvariables = ds_map_create();
ds_map_copy(tvariables, variables);
str = "var1 += var2 = (3*var3 - var2)";
//show_message("huh");
myfunc = MLP_InitParserCS(variables);
with (myfunc) {
    //values "1" are unnecessary as variables are already initialized.
    
    
    MLP_AddVariable("var1",1, MLP_VAL_REAL, false);
    MLP_AddVariable("var2",1, MLP_VAL_REAL, false);
    MLP_AddVariable("var3",1, MLP_VAL_REAL, true);
    MLP_SetExpression(other.str);
}


tvariables = ds_map_create();
ds_map_copy(tvariables, variables);
str = "str2= (str1=getstr(), strlen(str1)&lt;4 ? 's' : 'b')";
myfunc = MLP_InitParserCS(variables);
with (myfunc) {
    MLP_AddFunction("getstr",myGetString, MLP_VAL_STRING);
    MLP_AddFunction("strlen",myStringLength, MLP_VAL_REAL, MLP_VAL_STRING);
    
    MLP_AddVariable("str1","", MLP_VAL_STRING, false); 
    MLP_AddVariable("str2","", MLP_VAL_STRING, false);
    MLP_AddVariable("str3"); //automatically checks that "str1" is string (and sets var to unreadable
    MLP_SetExpression(other.str);
}

tvariables = ds_map_create();
ds_map_copy(tvariables, variables);
str = "ln(e^2^3)!";
myfunc = MLP_InitParserScience(variables);
with (myfunc) {
    MLP_SetExpression(other.str);
}

tvariables = ds_map_create();
ds_map_copy(tvariables, variables);
str = "(sin(pi / 2) *  -(4-2) + 1)/10 + globalvariable * (1/100) &lt;= rand() * 5"
myfunc = MLP_InitParserCS(variables);
with (myfunc) {
    MLP_AddVariable("globalvariable","globalvariable");
    MLP_AddVariable("pi","_pi");
    MLP_AddVariable("e","_e");
    MLP_AddVariable("var1","_var1");
    MLP_AddVariable("var2","_var2");
    MLP_AddVariable("var3","_var3");
    MLP_AddVariable("str1","_str1");
    MLP_AddVariable("str2","_str2");
    MLP_AddVariable("str3","_str3");
    
    MLP_AddBinaryOper("nPr",14.5,_MLP_FPermutation, MLP_VAL_REAL, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddBinaryOper("nCr",14.5,_MLP_FCombination, MLP_VAL_REAL, MLP_VAL_REAL, MLP_VAL_REAL);
    
    MLP_AddFunction("rand",myRandom, MLP_VAL_REAL);
    MLP_AddFunction("angle_difference",AngleDifference, MLP_VAL_REAL, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("not",_MLP_FNot, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("sin",_MLP_FSin, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("cos",_MLP_FCos, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("tan",_MLP_FTan, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("degrees",_MLP_FDegrees, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("radians",_MLP_FRadians, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("sqrt",_MLP_FSqrt, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("power",_MLP_FPower, MLP_VAL_REAL, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("round",_MLP_FRound, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("floor",_MLP_FFloor, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("ceil",_MLP_FCeil, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("frac",_MLP_FFrac, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("abs", _MLP_FAbs, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("arcsin", _MLP_FASin, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("arccos", _MLP_FACos, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("arctan", _MLP_FATan, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("exp", _MLP_FExp, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("ln", _MLP_FLn, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("log", _MLP_FLog, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("log2", _MLP_FLog2, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_AddFunction("logn", _MLP_FLogn, MLP_VAL_REAL, MLP_VAL_REAL, MLP_VAL_REAL);
    MLP_SetExpression(other.str);
}

with (MLP_objParser) {
    MLP_ClearExceptions();
    MLP_Calculate();
}

//ds_map_destroy(variables);*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with (MLP_objParser) {
    MLP_ClearExceptions();
    MLP_Calculate();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i, k;
i = 0;
//debug mode, for all parsers
k = 400;
draw_set_font(ft_code);


var num;
num = instance_number(MLP_objParser);
for (i = 0; i &lt; num; i += 1) {
    with (instance_find(MLP_objParser, i)) {
        if (MLP_HasAnswer()) {
            draw_set_color(c_black);
        } else {
            draw_set_color(c_red);
        }
        draw_text(0, i * 56,MLP_GetExprString() );
        draw_text(30,i * 56 + 14, MLP_LastExceptionString())
        draw_text(30,i * 56 + 28, "ans = " + string(MLP_GetFinalAnswer()));
        draw_set_color(c_black);
        draw_line(0,i*56,room_width,i*56);
    }
}
draw_set_color(c_black);
draw_line_width(k-5,0,k-5,560,2);
draw_line_width(0,560,room_width,560,2);

var j;
draw_set_font(ft_read);
j = 0;
draw_text(k,j,"shows a custom function, with 2 arguments"); j += 56;
draw_text(k,j,"shows a binarry operator#bitshifting"); j += 56;
draw_text(k,j,"shows the use of variables#pi is local, globalvariable global#"+
              "globalvariable = " + string(ds_map_find_value(variables,"globalvariable"))); j += 56;
draw_text(k,j,"shows a custom binary operator#precedence is set to higher than multiplication"); j += 56;
draw_text(k,j,"shows another function#without arguments"); j += 56;
draw_text(k,j,"shows the use of logical operators#Logical operators are lower in precedence than comparison#function is read as (2 &lt;= 4) ^^ (4 &gt; 5)"); j += 56;
draw_text(k,j,"shows a typical error which might occur always check for error after#calculating.  If an error occurs the answer is undefined#ALWAYS clear the error state before calculating"); j += 56;
draw_text(k,j,"shows various forms of assignment#initially all 3 variables are '1'#"+
              "var1 = " + string(ds_map_find_value(variables,"_var1")) + "  var2 = "+ string(ds_map_find_value(variables,"_var2")) + "  var3 = "+ string(ds_map_find_value(variables,"_var3"))); j += 56;
draw_text(k,j,"shows use of strings, the comma opearator # and the use of the ternary 'conditional' operator#"+
              "str1 = " + string(ds_map_find_value(variables,"_str1")) + "  str2 = "+ string(ds_map_find_value(variables,"_str2"))); j += 56;
draw_text(k,j,"Shows a complete different setup of operators, using Science#"+
              "'^' is to the power of, ! means factorian, 'e' is the mathematical const#"+
              "ln(e^2^3) is read as ln(e^(2^3)) = 8#");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
str = get_string("new function", str);
with (myfunc) {
    MLP_SetExpression(other.str);
    MLP_ClearExceptions();
    MLP_Calculate();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
